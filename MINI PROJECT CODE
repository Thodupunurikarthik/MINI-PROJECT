import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
import numpy as np
import matplotlib.pyplot as plt

# Define paths
train_dir = '/Users/Saibharat/Desktop/Mini Project/Dataset/dataset'
model_path = '/Users/Saibharat/Desktop/Mini Project/Dataset/files/best_model1.keras'

# Parameters
img_height, img_width = 224, 224
batch_size = 32
num_classes = 4  # Assuming each folder represents a class
epochs = 10

# Data Preparation
def create_data_generators(train_dir, img_height, img_width, batch_size):
    train_datagen = ImageDataGenerator(
        rescale=1.0 / 255,
        rotation_range=20,
        width_shift_range=0.2,
        height_shift_range=0.2,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True,
        validation_split=0.2
    )

    train_generator = train_datagen.flow_from_directory(
        train_dir,
        target_size=(img_height, img_width),
        batch_size=batch_size,
        class_mode='categorical',
        subset='training'
    )

    validation_generator = train_datagen.flow_from_directory(
        train_dir,
        target_size=(img_height, img_width),
        batch_size=batch_size,
        class_mode='categorical',
        subset='validation'
    )

    return train_generator, validation_generator

train_generator, validation_generator = create_data_generators(train_dir, img_height, img_width, batch_size)

# Model Creation
def create_model(input_shape, num_classes):
    model = Sequential([
        Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),
        MaxPooling2D((2, 2)),
        Conv2D(64, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Conv2D(128, (3, 3), activation='relu'),
        MaxPooling2D((2, 2)),
        Flatten(),
        Dense(512, activation='relu'),
        Dropout(0.5),
        Dense(num_classes, activation='softmax')
    ])

    model.compile(optimizer=Adam(),
                  loss='categorical_crossentropy',
                  metrics=['accuracy'])

    return model

model = create_model((img_height, img_width, 3), num_classes)
model.summary()

# Model Training
def train_model(model, train_generator, validation_generator, epochs):
    early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)
    model_checkpoint = ModelCheckpoint(model_path, save_best_only=True, monitor='val_loss')

    history = model.fit(
        train_generator,
        epochs=epochs,
        validation_data=validation_generator,
        callbacks=[early_stopping, model_checkpoint]
    )

    return history

history = train_model(model, train_generator, validation_generator, epochs)
# Plot training & validation accuracy values
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(loc='lower right')
plt.show()

# Plot training & validation loss values
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(loc='upper right')
plt.show()

# Save the model using Keras' save function
model.save(model_path)

# Load the model using Keras' load_model function
def load_saved_model(model_path):
    model = load_model(model_path)
    print(f"Model loaded from {model_path}")
    return model

loaded_model = load_saved_model(model_path)

# Prediction
def predict_image(model, img_path, img_height, img_width, class_indices):
    img = load_img(img_path, target_size=(img_height, img_width))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.0

    prediction = model.predict(img_array)
    predicted_class = np.argmax(prediction, axis=1)[0]

    class_labels = {v: k for k, v in class_indices.items()}
    predicted_label = class_labels[predicted_class]

    return predicted_label

# Example usage:
img_path = '/Users/Saibharat/Desktop/Mini Project/Dataset/image.jpeg'
predicted_label = predict_image(loaded_model, img_path, img_height, img_width, train_generator.class_indices)
print(f'This shot is classified as: {predicted_label}'


import tensorflow as tf
from tensorflow.keras.preprocessing.image import load_img, img_to_array
from tensorflow.keras.models import load_model
import numpy as np
import matplotlib.pyplot as plt
import os

# Path to the saved model
model_path = '//Users/Saibharat/Library/Application Support/JetBrains/PyCharm2024.1/scratches/best_model.keras'

# Parameters
img_height, img_width = 224, 224


# Load the saved model
def load_saved_model(model_path):
    model = load_model(model_path)
    print(f"Model loaded from {model_path}")
    return model


loaded_model = load_saved_model(model_path)

# Ensure the model is built by making a dummy prediction
dummy_input = np.random.random((1, img_height, img_width, 3)).astype(np.float32)
loaded_model.predict(dummy_input)

# Class indices (ensure this matches your training data)
class_indices = {'drive_shot': 0, 'Flick_shot': 1, 'Pull_shot': 2, 'sweep_shot': 3}
class_labels = {v: k for k, v in class_indices.items()}


# Prediction function
def predict_image(model, img_path, img_height, img_width, class_labels):
    img = load_img(img_path, target_size=(img_height, img_width))
    img_array = img_to_array(img)
    img_array = np.expand_dims(img_array, axis=0)
    img_array /= 255.0

    prediction = model.predict(img_array)
    predicted_class = np.argmax(prediction, axis=1)[0]
    predicted_label = class_labels[predicted_class]
    predicted_accuracy = np.max(prediction)

    return predicted_label, predicted_accuracy, prediction


# Function to generate accuracy report, print results, and display the RGB image
def accuracy_report(img_path, model, class_labels, img_height=224, img_width=224, threshold=0.7):
    label, accuracy, prediction = predict_image(model, img_path, img_height, img_width, class_labels)

    print(f"Predicted Label: {label}")
    print(f"Prediction Accuracy: {accuracy:.2f}")

    if accuracy >= threshold:
        print(f"Classified correctly with high accuracy: {accuracy:.2f}")
    else:
        print(f"Classified with low accuracy: {accuracy:.2f}")

    print(f"Class confidences: {prediction[0]}")

    # Visualize the input image
    img = load_img(img_path, target_size=(img_height, img_width))
    img_array = img_to_array(img)
    plt.figure(figsize=(8, 8))
    plt.imshow(img_array.astype('uint8'))
    plt.title("Input Image")
    plt.axis('off')
    plt.show()

    # Generate and print the accuracy report
    report = (
        f"Accuracy Report\n"
        f"Predicted Label: {label}\n"
        f"Prediction Accuracy: {accuracy:.2f}\n"
        f"Class Confidences: {prediction[0]}\n"
    )
    print(report)

    # Save the report to a file
    report_path = os.path.splitext(img_path)[0] + '_accuracy_report.txt'
    with open(report_path, 'w') as f:
        f.write(report)
    print(f"Accuracy report saved to {report_path}")


# Example usage
img_path = '/Users/Saibharat/Desktop/Mini Project/Dataset/ Testing Data/sweep12.jpeg'
accuracy_report(img_path, loaded_model, class_labels)
